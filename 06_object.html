<html>
    <head>
        <meta charset="UTF-8">
        <title>Document</title>
        <link rel="stylesheet" href="main.css">
    </head>
    <body>
        
        <script>           
            'use strict';
            
            // Objects
            // one of the JavaScript's data types.
            // a collection of related data and/or functionality.
            // Nearly all objects in JavaScript are instances of Object
            // object = { key : vlaue }
            
            // 1. Literals and properties
            const obj1 = {};  // 'object literal' syntax
            const obj2 = new Object(); // 'object constructor' syntax
            
            function print(person){
                console.log(person.name);
                console.log(person.age);
            }
            
            const ellie = {name:'ellie', age:4};
            print(ellie);
            
            // with JavaScript magic (dynamically type language)
            // can add proerties later
            ellie.hasJob = true;
            console.log('hasJob:'+ellie.hasJob);
            // can delete properties later
            delete ellie.hasJob;
            console.log('hasJob:'+ellie.hasJob);
            
            
            // 2. Computed properties
            // key should be always string
            console.log(ellie.name);     // propertie의 이름을 정확이 알고있는경우 일반적 코딩
            console.log(ellie['name']);  // propertie의 이름을 동적으로 받아와서 사용해야 할 경우에
            
            ellie['hasJob'] = true;
            console.log('hasJob:'+ellie.hasJob);
            
            function printValu(obj,key){
                console.log(obj.key);  // 출력되지 않음
                console.log(obj[key]); // 출력됨
            }
            printValu(ellie,'name');
            printValu(ellie,'age');
            
            
            // 3. Property value shorthand
            const person1 = {name:'bob',age:2};
            const person2 = {name:'steve',age:3};
            const person3 = {name:'dave',age:4};
            const person4 = makePerson('ellie',30);
            console.log(person4);
            function makePerson(name,age){
                
                return {
                    name: name,
                    age: age
                };
                
                //key와 value의 이름이 동일하다면 생략할 수 있다. - explorer에서 error
                /*
                return{
                    name,
                    age
                };
                */
            }
            
            // 4. Constructor function
            function Person(name,age){
                // this = {}; //생략구문
                this.name = name;
                this.age = age;
                //return this; //생략구문
            }
            const person5 = makePerson('sujan',33);
            console.log(person5);
            
            // 5. in operator: property existence check ( key in obj)
            console.log('name' in ellie);
            console.log('age' in ellie);
            console.log('random' in ellie);
            
            // 6. for..in vs for..of
            // for (key in obj)  - object의 모든키를 받아서..
            for(let key in ellie){
                console.log(key);
            }
            
            // 7.for (value of iterable)
            // 배열과같, 배열리스트       ---- explorer에서 에러
            /*
            const array = [1,2,3,4,5];
            let cnt = 0;
            for( let value of array){
                console.log('array['+(cnt++)+']='+value);
            }
            */
            
            // 8. Fun cloning
            // Object.assign(dest,[ obj1, obj2, obj3... ])
            // 오브젝트의 메모리값은 ref(페퍼런스)값이고 이 레퍼런스는 메모리상에 오브젝트의 필드값을 가리킨다.
            // B오브젝트에 A오브젝트를 할당하면 필드값이 아니고 ref(레퍼런스)값이 할당된다.
            // 때문에 B의 필드값을 변경하면 A의 필드값이 바뀐다. (ref 값이 같음으로)
            // 때문에 오브텍트 복제가 필요하다.
            const user = {name:'ellie',age:'20'};
            const user2 = user;
            console.log(user);
            user2.name = 'another name';
            console.log(user);
            
            user2.name = 'ellie'; //원래대로
            // old
            const user3 = {};
            for(let key in user){
                user3[key] = user[key];
            }
            console.log(user3);
            
            // now
            const user4 = {};
            Object.assign(user4,user);
            console.log(user4);
            // or now
            const user4_1 = Object.assign({},user);
            console.log(user4_1);
            // 여러개를 혼합하여 복사할 수있다.
            // 이경우 같은 필드는 뒤의 오브젝트의 값으로 덮어 씌워진다.
            const fruit1 = {color:'red'};
            const fruit2 = {color:'blue',size:'big'};
            const mixed = Object.assign({},fruit1,fruit2);
            console.log(mixed);
            
            
        </script>
    </body>
</html>